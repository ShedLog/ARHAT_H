### Описание библиотеки
_(как работает, что содержит, куда пользоваться)_

*Поддерживаемые варианты:*
* Ардуино Мега2560 и аналоги на базе МК Atmel2560/2561, Atmel1280/1281 .. 
* Ардуино UNO,NANO,MINI и аналоги на базе МК Atmel328p, Atmel168p, Atmel48p ..

#### Введение

Первоначально, библиотека создавалась как задача "освоения" Ардуино и Wiring (вспомнить С/С++), но сразу переросла в
решение вопроса минимизации и ускорения скетчей. Дальнейшее развитие направлено на постепенную замену Wiring.

  Недостаток: библиотека *требует* определения номеров используемых пинов только константным способом!
* `int pinForShield = 13;` -- *так работать не будет!*
* `#define pinForShield  13` -- **так правильно**

> _Пожелания по разработке - принимаются, но их реализация только "по мере наличия времени"._

##### Правила нумерации пинов плат:
* а) по возможности сохраняется нумерация контактов на платах Ардуино, начиная с 0;
* б) нумерация аналоговых входов *продолжает* нумерацию остальных контактов платы;

> Как следствие, традиционное макроопределение Analog3 тут имеет номер 57 для Ардуино Мега2560.
> .. и все остальные специальные названия контактов возвращают сквозной номер пина.

### Описание макросов, типов и функций библиотеки
#### Предопределенные константы для выводов плат:

`эти описания находятся в файлах "распиновки" соответствующих плат arhat_pins2560.h и arhat_pins328p.h`

* pin0..pin53 -- номер "цифровых выводов" для Ардуино Мега2560 (для UNO - меньше)
* pinLed      -- номер вывода встроенного светодиода платы
* Analog0 .. Analog15   -- номера аналоговых выводов плат (сквозные! продолжение счета после pin53)
* pwm2 .. pwm13, T1C    -- номера выводов с возмижностью ШИМ.
* INT_0 .. INT_5        -- номера выводов прерываний
* PC_INT_0 .. PC_INT_23 -- нумерация выводов прерываний PCINT

#### Системный таймер, функции времени и задержек:

Под учет системного времени (микросекунды, миллисекунды и пр.) выделен таймер 0, также как и у wiring. Его можно изменить,
равно как и частоту учета времени, используя макроопределения:
 * TIME_DEFAULT     -- номер таймера, который будет учитывать время
 * TIME_MAX_COUNTER -- до какого значения считает таймер (только информация для учета! Настраивать таймер самостоятельно!)
 * TIME_PRESCALLER  -- на какой частоте установлен прескалер таймера
 * TIME_MODE        -- режим счета таймера
 * TIME_TICK_MCS    -- константа длительности 1 тика таймера в микросекундах
 * TIME_SHIFT       -- "сдвиг" счетчика от прескалера: пересчет в мксек. Для прескалеров <4мксек - сдвиг вправо, иначе - влево.
 * TIME_MCS2MS      -- множитель: "отношение" длительности в мксек до переполнения счетчика к 1000 мксек 
 * TIME_ISR         -- тип прерывания, обрабатывающего системное время
 Переопределение этих констант - взаимозависимо и требует понимания того, что Вы делаете. Они должны быть определены ДО
включения файла arhat.h

* Макросы и функции времени и задержек:
  * **delayMicro8**()            -- 8бит: короткий цикл по 3 такта (16Мгц = 187.25 наносек.)
  * **delayMicro16**()           -- 16бит: тоже циклом, но по 4 такта (16Мгц = 250 нсек.)
  * **delayMicroSeconds**()      -- аналог предыдущего для привычных к wiring
  * void **time_delay**(ulong);  -- выполнить цикл задержки в миллисекундах .. вплоть до 49.7 дней.
  * void **time_delay16**(uint); -- экономия на вызове, если не надо слишком долго. Тоже задержка в миллисекундах до 65.5 сек.
  * void **delay**(ulong);       -- аналог предыдущей(!) функции для wiring-совместимости

  * uint32_t **time_micros**(void); -- получить текущее время в микросекундах (переполнение через 1.19 часа от старта)
  * uint32_t **time_millis**(void); -- получить текущее время в миллисекундах (переполнение через 49.7 дней)
  * **millis**(), **micros**()      -- аналоги для совместимости 

  * uint32_t **getOvfCount**(void); -- позволяет получить количество текущих тиков консистентно, закрыв прерывания на момент чтения.

  * **everyMillis**() -- "автоматный макрос": позволяет исполнять код через заданные миллисекунды и прописывать его прямо внутри макроса
  * **everyOVF**()   -- облегченная версия. Тоже самое, но учет времени в тиках системного таймера.

  * Исполнение кода в заданное время (sheduller):
 Обработчик системного таймера позволяет указать функцию без параметров, которая будет вызываться каждый раз (каждые 1024мксек)
при его активизации - "хук времени". Процедура хука исполняется с открытыми прерываниями, что не мешает продолжению счета
системного времени или каких ещё обработчиков. В случае длительного исполнения хука - его повторный вызов блокируется до
завершения. То есть, пока хук не завершит свою работу повторно он вызван *не будет*.  
 Для включения компиляции с хуком таймера, в файле arhat.c требуется изменить режим на 3. По умолчанию - хук отсутствует.

  * TimerHookProc **setTimerHook**(TimerHookProc); Установить процедуру хука. Возвращает предыдущее значение (можно организовывать очереди)
  * **pushAllRegs**() -- сохранение текущего контекста исполнения на стеке, с подменой точки возврата для корректного выхода отсюда.
  * **popAllRegs**()  -- восстановление контекста, предварительного сохраненного на стеке пред. функцией (общий уровень исполнения!) 

####  Макросы ногодрыгов (прямой ввод-вывод на ножки платы)

`**ВНИМАНИЕ!** Все макросы прямого управления выводами требуют указания номера вывода константой, не переменная!`

* **pinModeOut**(p)    -- Превращает ножку в ВЫХОД. При включении все ножки настроены на ВВОД
* **pinModeIn**(p)     -- Настраивает ножку на ВВОД. Подтяжка к +5в зависит от текущего значения выведенного на эту ножку ранее
* **pinModePullIn**(p) -- Настройка на ВВОД с подтяжкой к +5в.

* **pinOutHigh**(p) -- Вывод на ножку лог."1". Ножка предварительно должна быть настроена на ВЫВОД.
* **pinOutLow**(p)  -- Вывод на ножку лог."0". Аналогично.
* **pinOut**(p,v)   -- Объединение предыдущих двух макросов: ВЫВОД на ножку заданного уровня (можно из переменной)
* **pinRead**(p)    -- Чтение логического уровня ножки.

* digitalWrite(p,v) -- переопределение на макрос pinOut() с целью прямого импорта скетчей из Wiring
* digitalRead(p)    -- аналогичное переопределение на pinRead() с той же целью.

#### Макросы управления таймерами (прямое управление через регистры)

`**ВНИМАНИЕ!** Все макросы также требуют указания номера таймера константой, не переменная!`
`Регистры таймера так и указываются БУКВАМИ: A,B,C -- это не переменные, а часть макро-имени!`
`Допустимые значения: t:[0,2,[1,3,4,5]], r:[A,B[,C]], то есть для 16-битных таймеров есть ещё и канал "C"`
`Допустимые значения для прерываний от таймеров: t:[0,2[,1,3,4,5]] v:[OVF,COMPA,COMPB[,COMPC,CAPT]], b:[0,1] -- clear/set`

* **timerCount**(t)     -- Установить/получить текущее значение счетчика таймера
* **timerControl**(t,r) -- Установить/получить текущее значение регистра управления таймера (A,B,C)
* **timerCompare**(t,r) -- Установить/получить текущее значение регистра сравнения таймера (A,B,C)
* **timerCapture**(t)   -- Установить/получить значение регистра захвата таймера (только 16-битных: 1,3,4,5)
* **prescalerMode**(pr) -- Получить код для прескалера таймера по числу делителя (64 --> 3 удобства для)

* **timerIMask**(t,v,b) -- Установить/получить маску прерываний таймера (см. третье примечание выше)
* **timerIFlag**(t,v)   -- Получить состояние флага прерывания от таймера
* **ISRtimer**(t,v)     -- Сформировать имя обработчика прерывания для макроса ISR()

#### Макросы работы с аппаратным ШИМ (PWM) выводами

`**ВНИМАНИЕ!** Номер вывода также задается только константно. Не переменная!`
`Допустимые номера выводов для ШИМ mega2560: p:[2..13,44,45,46, T1C]. Имя T1C - для указания 13 вывода как канал С таймера 1`
`Допустимые номера выводов на остальные МК - смотреть в документации к ним`
`Значения режимов работы ШИМ на выводах для pwmPinMode(): m[PWM_DISABLE,PWM_TOGGLE,PWM_NORMAL,PWM_INVERSE]`
`Стандартный режим ШИМ: делитель 1/64 (1 такт = 4 мксек), режим "8-битного fastPWM" для 8/16 таймеров.`

* **pwmGetTimer**(p)   -- (вспом.) получить номер таймера, обслуживающего заданный вывод ШИМ
* **pwmGetChannel**(p) -- (вспом.) получить номер канала, обслуживающего заданный вывод ШИМ

* **pwmPinMode**(p,m)  -- Установить вывод в режим стандартного ШИМ и задать режим вывода
* **pwmSet**(p)        -- Настроить вывод и его таймер на стандартный ШИМ
* **pwmOff**(p)        -- Выключить вывод из ШИМ. Вывод остается "на выход". Весь таймер - не отключаем
* **pwmWrite**(p,v)    -- Вывести заданное значение ШИМ. Значение может быть и из переменной/выражения [0..255]

`"сервоШИМ" для управления типовыми сервомоторами (**только для 16-битных таймеров!**):
 Режим таймера = 14 (FAST-pwm mode with ICP), прескалер = 3 (1/64), ICP=5000
... В результате имеем ШИМ с частотой 50гц (20мсек)`

* **timerSetServo**(t,pwmPinMask) -- Установить заданный таймер в режим "сервоШИМ" и активизировать заданные каналы "оптом"
* **pwmSetServo**(p1) -- Установка **вывода** и его таймера в "сервоШИМ" Для последующего канала этого же таймера достаточно вызвать pwmSet(p).

#### Макросы для работы с аналоговыми сигналами

* **adc_read**(p) -- Читать значение АЦП на заданном входе (константа!). Ожидать завершения оцифровки.

* **admuxSrc**(s) -- Получить маску для опорного напряжения s:[AREF,AVCC,110,256]
* **adcOn**()     -- Включение АЦП отдельной командой и настройка частоты оцифровки: 16Mhz/128 (125kHz)
* **adcOff**()    -- Выключение АЦП. Нормально - выключен, ибо "жрет" - много

* **admux1Channel**(src,pin,adlar)     -- АЦП на заданном входе pin:[0..15] (измерение от 0 - GND)
* **admux2Channel**(src,neg,poz,adlar) -- дифференциальный режим АЦП neg:[1,2|9,10], poz:[0..7|8..15] 
* **admux2Gain**(src,neg,poz,g,adlar)  -- дифф. режим с пред. усилителем neg:[0,2|8,10], poz:[0..3|8..11], g:[GAIN_10,GAIN_200], adlar:[ADC_LEFT|ADC_RIGHT]

 Примеры настройки режимов АЦП:

* admux1Channel(admuxSrc(110), 5, ADC_RIGHT);           -- поставить АЦП в режим сравнения с опорным в 1.1в, читать 5 вход, значения 0..1023
* admux2Channel(admuxSrc(AREF), 10, 11, ADC_LEFT);      -- сравнивать с AREF, дифференциальный режим 10,11, значения домножены на 64 [64..65535].
* admux2Gain(admuxSrc(AVCC), 0, 1, GAIN_200, ADC_LEFT); -- сравнивать с Vсс, предусилитель 200х, дифф. режим 0,1; домножены на 64 [64..65535].

#### Чтение/запись EEPROM:

* unsigned char **EEPROM_read**(unsigned int uiAddress); -- прочитать 1 байт из ЕЕПРОМ по адресу
* void **EEPROM_write**(unsigned int uiAddress, unsigned char ucData) -- записать 1 байт по заданному адресу ЕЕПРОМ

#### Работа с прерываниями PCINT (подсчет срабатываний, чтение длительностей сигналов):

`Внимание! Для Ардуино Мега 2560 не определена работа с прерываниями PC_INT_1 !!!`

`Для Ардуино УНО (ATmega328p) определены все уровни PCINT`

Использование прерываний PCINT достаточно простое: для этого необходимо определить константы PCINT, MAX_PULSES и подключить
 файл **#include "pcint.h"**. Для подключения ещё одного уровня требуется переопределить константу PCINT и подключить этот
 файл повторно:
 
`#define MAX_PULSES 4`

`#define PCINT 2`

`#include "pcint.h"`

`#define PCINT 1`

`#include "pcint.h"`

Обрабатываем 4 вектора в двух уровнях прерываний. Какие и сколько в функциях ниже..

##### a) функции работы с прерываниями PCINT

Поскольку все функции авто-создаются через подключение файла pcint.h с предварительно установленным номером уровня прерывания,
 то в названиях функций добавляем номер уровня, ниже обозначенный как [0..2]. Для использования конкретной функции,
 в её имени требуется указывать номер уровня прерывания, например: pcint**0**_init(параметры) 

  * uint8_t  **pcint[0..2]_init**(uint8_t pulseID, uint8_t pin, uint8_t state, PcintMethod method, TSC_Time timeout); -- Инициализация обработчика прерывания требуемого уровня. Возвращает номер вектора прерывания [0..7]:

  * void     **pcint[0..2]_start**(uint8_t intNumber); -- Запуск замера по вектору [0..7] заданного уровня прерываний. Номер вектора возвращает функция pcint_init() (см. выше)

  * TSC_Time **pulseIn[0..2]**(uint8_t pulseId, void (*action)(void)); -- Измерение длительности импульса по прерыванию с ожиданием результата замера (аналог pulseIn)
**action** - функция без параметров, которая будет выполняться, пока идет ожидание длительности импульса (дабы не простаивать).

  * **ptrPulse**(ptr) -- преобразование (приведение) указателя к типу данных **Pulse**

##### b) константы, определенные для обработки прерываний PCINT
  * PULSE_BUSY, PULSE_SECOND, PULSE_OK, PULSE_TIMER, PULSE_ERROR -- состояния обработчика прерываний.
  * PULSE_RAISING, PULSE_FAILING, PULSE_BOTH -- способы подсчета количества прерываний (энкодер)

Константы состояния и способа подсчета указываются в параметре **state** для pcint_init() -- в какое состояние перевести обработчик.
Также могут проверяться программно: поле **pulse**[].state хранит текущее состояние обработчика.

  * PCINT -- номер уровня прерывания для подключения файла pcint.h
  * MAX_PULSES -- сколько всего (всех уровней) будет обрабатываться прерываний - указывается 1 раз перед первым включением.

##### c) методы (способы) работы обработчиков PCINT (пока только 2)

Имена этих функций указываются в pcint_init() -- "что делать обработчику прерывания". Можно написать свой.

  * void **pcint_micros**( void *ptr, uint8_t oldBit );  -- способ замера: "замер длительности импульса от прерывания до прерывания"
  * void **pcint_encoder**( void *ptr, uint8_t oldBit ); -- ещё способ: "подсчет количества фронтов/спадов/оба .. до таймаута"

**ДЛЯ РАЗРАБОТЧИКОВ собственных методов обработки и применения прерываний PCINT:**

  * void **pcint_end**(Pulse * ptrPulse, uint8_t error); -- (вспом.) завершает обработку замера, запрещает прерывание от этого пина(!)

##### d) вспомогательные макросы для получения регистров, бит и текстовок (ресурсов МК) по уровню прерывания: [0,1,2]
  * **PCINT_DDR**(n)  -- регистр настройки порта, который обслуживает этот уровень прерываний 
  * **PCINT_PORT**(n) -- регистр вывода порта, обслуживающего данный уровень прерываний
  * **PCINT_PIN**(n)  -- регистр ввода порта
  * **PCINT_MSK**(n)  -- регистр маски прерывания
  * **PCINT_NAME**(n) -- формирует имя обработчика прерывания по его уровню

  * **PCINT_pin2number**(n,p) -- перевод уровня прерывания (0,1,2) и номера пина платы в номер вектора прерывания PCINT 0..7

##### e) типы данных и структуры для PCINT

  * typedef void (* **PcintMethod**)( void *ptrPulse, uint8_t ); -- функции-обработчики прерывания "способ обработки".
  * typedef struct{} **Pulse** -- место хранения таймаута измерения длительностей, результата, способа измерения и пина платы ..

##### f) структуры харанения данных для обработчика прерывания заданного уровня:

`Структуры данных определяются и добавляются в код только для указанного уровня прерываний PCINT!`

  **Pulse** **pulses**[MAX_PULSES]; -- единый массив данных и результатов для всех включенных прерываний всех уровней 

  **uint8_t** **numbers0**[8], **numbers1**[8], **numbers2**[8] -- внутренние индексы для связи номера прерывания [0..7] с местом хранения данных в **pulses**

  **uint8_t** **pcint0old**, **pcint1old**, **pcint2old** -- предыдущее состояние пинов уровней прерываний PCINT

#### I2C (TWI) работа с интерфесом

Организована на базе аппаратного драйвера I2C(TWI) через конечный автомат на прерывании. Особенности:
* Возможность управления режимом компиляции программы, с целью уменьшения размера в случаях когда полная реализация интерфейса не требуется.
Так наиболее популярный режим Master Transmitter (управление без чтения) реализован менее чем в 200байт.

* Отсутствие внутренней буферизации. Их размеры и места хранения - дело вашей программы, если надо.

* Неблокирующая работа аппаратного драйвера, сохраненная в функциях чтения/записи. Функции только запускают автомат и возвращают
управление в программу. Далее обмен идет самостоятельно.

* Возможность создания собственных обработчиков завершения сеансов, позволяющая реализовать алгоритмы работы произвольной сложности во всех режимах
 
##### Подключение интерфейса
Перед включением файла **#include "arhat_twi.h"** требуется указать режим компиляции константой **TWI_ON** (определны в arhat.h)
  * TWI_MASTER_TX, TWI_MASTER_RX, TWI_IS_SLAVE_RX, TWI_IS_SLAVE_TX, TWI_LOG_ON
, объединяя требуемые блоки логическим "или" (|):

`#include "arhat.h"`

`#defune TWI_ON TWI_MASTER_TX | TWI_MASTER_RX`

`#include "arhat_twi.h"`

##### Функции, макрокоманды, структуры данных для работы с I2C

* Режимы работы I2C(TWI) и состояния автомата

  * uint8_t **twiState** -- Состояния аппаратного драйвера I2C(TWI). Значения полностью совпадают со статусами из datasheet.
  * uint8_t **twiMode**  -- Режим текущей работы: TWI_IS_SLAVE (slave активен), TWI_SEND_STOP (будет перезапуск сеанса), TWI_READY (сеанс завершен)

* Callback функции для перехвата действий по ситуациям
Все перехватчики - указатели на функции без параметров и возвратов! Все они по умолчанию отсутствуют и могут быть назначены по необходимости.

`Поскольку режим **Slave** предполагает асинхронное ожидание начала сеанса, то его обработчики должны быть заданы явно до инициализации режима.` 

  * **twiHookRestart** -- указатель на функцию перезапуска мастера без освобождения шины (TWI_SEND_STOP).
Позволяет перехватить управление после завершения сеанса передачи/приема и начать новую передачу/прием без освобождения шины.
`Если установлен режим TWI_SEND_STOP и не назначена тут функция - запустится режим "чтение после записи" по тому же адресу, см. twiRAW()!`

  * **twiMasterReader** -- указатель на функцию "Master принял данные, куда их?". Получает управление сразу же по факту исчерпания
буфера передачи. Позволяет оперативно перезагрузить буфер передачи и продолжить или произвести какие-то ещё действия из под прерывания.

  * **twiSlaveReader** -- указатель на функцию "Slave принял данные, куда их?". **Обязателен!** Вызывается из под обработчика прерывания интерфеса и
может предпринять какие-то действия с принятыми данными и/или изменить режим работы драйвера.

  * **twiSlaveWriter** -- указатель на функцию "Slave всё отправил, что дальше?". **Обязателен** Вызывается также из под
обработчика и должен предпринять какие-то действия по завершению передачи буфера по запросу внешнего мастера.

* Функции настройки и запуска интерфейса
  * **twiOn**()  -- подать питание на аппаратную часть интерфейса (по умолчанию - включен)
  * **twiOff**() -- выключить питание интерфейса (для экономии: жрет много)
  * void **twiSetup**(uint32_t freq, uint8_t mode) -- инициализация I2C с установкой скорости обмена и режима

* Функции работы с интерфесом
  * void **twiWrite**(uint8_t address, const uint8_t * data, uint8_t length); -- отправка в режиме Master Transmitter
  * void **twiRead**(uint8_t address, uint8_t * data, uint8_t length); -- Чтение в режиме Master Receiver
  * void **twiRAW**(uint8_t address, uint8_t *command, uint8_t clength, uint8_t *data, uint8_t dlength); -- совмещенная
операция "чтение после записи" для одного адреса. Отправляет команду(ы) на адрес и переходит в режим чтения данных с
устройства без освобождения шины I2C 

* Вспомогательные функции и макроопределения
  * **twiSetRate**(_twbr, _twsr) -- установить заданную скорость интерфейса прямой записью в регистры
  * void **twiSpeed**(uint32_t freq) -- установить заданную скорость I2C(TWI)
  * **twiStart**(ack)                -- Начать захват шины

* Вспомогательные макросы и функции для разработчиков методов работы с интерфесом типа twi_RAW()
  * void **_twiStartTo**(uint8_t address) -- начать передачу с устройством по адресу
  * void **_twiStartRe**(uint8_t address) -- начать передачу с последующим рестартом сеанса без освобождения шины
  * **_twiWaitReady**() -- ждать завершения предыдущего сеанса и занять шину
  * **_twiMT_Buffer**(data, length) -- настроить буфер передачи для режима Master Transmitter
  * **_twiRX_Buffer**(data, length) -- настроить буфер приема для режимов Master Receiver и Slave Receiver
  * **_twiST_Buffer**(data, length) -- настроить буфер передачи для режима Slave Transmitter

* Режим логирования интерфейса
(продолжение следует)