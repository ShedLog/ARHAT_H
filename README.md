### Описание библиотеки
_(как работает, что содержит, куда пользоваться)_

*Поддерживаемые варианты:*
* Ардуино Мега2560 и аналоги на базе МК Atmel2560/2561, Atmel1280/1281 .. 
* Ардуино UNO,NANO,MINI и аналоги на базе МК Atmel328p, Atmel168p, Atmel48p ..

#### Введение

Первоначально, библиотека создавалась как задача "освоения" Ардуино и Wiring (вспомнить С/С++), но сразу переросла в
решение вопроса минимизации и ускорения скетчей. Дальнейшее развитие направлено на постепенную замену Wiring.

  Недостаток: библиотека *требует* определения номеров используемых пинов только константным способом!
* `int pinForShield = 13;` -- *так работать не будет!*
* `#define pinForShield  13` -- **так правильно**

> _Пожелания по разработке - принимаются, но их реализация только "по мере наличия времени"._

##### Правила нумерации пинов плат:
* а) по возможности сохраняется нумерация контактов на платах Ардуино, начиная с 0;
* б) нумерация аналоговых входов *продолжает* нумерацию остальных контактов платы;

> Как следствие, традиционное макроопределение Analog3 тут имеет номер 57 для Ардуино Мега2560.
> .. и все остальные специальные названия контактов возвращают сквозной номер пина.

### Описание макросов, типов и функций библиотеки
#### Системный таймер, функции времени и задержек

Под учет системного времени (микросекунды, миллисекунды и пр.) выделен таймер 0, также как и у wiring. Его можно изменить,
равно как и частоту учета времени, используя макроопределения:
 * TIME_DEFAULT     -- номер таймера, который будет учитывать время
 * TIME_MAX_COUNTER -- до какого значения считает таймер (только информация для учета! Настраивать таймер самостоятельно!)
 * TIME_PRESCALLER  -- на какой частоте установлен прескалер таймера
 * TIME_MODE        -- режим счета таймера
 * TIME_TICK_MCS    -- константа длительности 1 тика таймера в микросекундах
 * TIME_SHIFT       -- "сдвиг" счетчика от прескалера: пересчет в мксек. Для прескалеров <4мксек - сдвиг вправо, иначе - влево.
 * TIME_MCS2MS      -- множитель: "отношение" длительности в мксек до переполнения счетчика к 1000 мксек 
 * TIME_ISR         -- тип прерывания, обрабатывающего системное время
 Переопределение этих констант - взаимозависимо и требует понимания того, что Вы делаете. Они должны быть определены ДО
включения файла arhat.h

* Макросы и функции времени и задержек:
  * **delayMicro8**()            -- 8бит: короткий цикл по 3 такта (16Мгц = 187.25 наносек.)
  * **delayMicro16**()           -- 16бит: тоже циклом, но по 4 такта (16Мгц = 250 нсек.)
  * **delayMicroSeconds**()      -- аналог предыдущего для привычных к wiring
  * void **time_delay**(ulong);  -- выполнить цикл задержки в миллисекундах .. вплоть до 49.7 дней.
  * void **time_delay16**(uint); -- экономия на вызове, если не надо слишком долго. Тоже задержка в миллисекундах до 65.5 сек.
  * void **delay**(ulong);       -- аналог предыдущей(!) функции для wiring-совместимости

  * uint32_t **time_micros**(void); -- получить текущее время в микросекундах (переполнение через 1.19 часа от старта)
  * uint32_t **time_millis**(void); -- получить текущее время в миллисекундах (переполнение через 49.7 дней)
  * **millis**(), **micros**()      -- аналоги для совместимости 

  * uint32_t **getOvfCount**(void); -- позволяет получить количество текущих тиков консистентно, закрыв прерывания на момент чтения.

  * **everyMillis**() -- "автоматный макрос": позволяет исполнять код через заданные миллисекунды и прописывать его прямо внутри макроса
  * **everyOVF**()   -- облегченная версия. Тоже самое, но учет времени в тиках системного таймера.

* Исполнение кода в заданное время (sheduller):
 Обработчик системного таймера позволяет указать функцию без параметров, которая будет вызываться каждый раз (каждые 1024мксек)
при его активизации - "хук времени". Процедура хука исполняется с открытыми прерываниями, что не мешает продолжению счета
системного времени или каких ещё обработчиков. В случае длительного исполнения хука - его повторный вызов блокируется до
завершения. То есть, пока хук не завершит свою работу повторно он вызван *не будет*.  
 Для включения компиляции с хуком таймера, в файле arhat.c требуется изменить режим на 3. По умолчанию - хук отсутствует.

* TimerHookProc **setTimerHook**(TimerHookProc); Установить процедуру хука. Возвращает предыдущее значение (можно организовывать очереди)

... продолжение следует ...