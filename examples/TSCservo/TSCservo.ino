/**
 * "КА Серводвигатель".
 * размер компилированного скетча = 876байт., SRAM = 22байт.
 *
 * Аппаратное, плавное управление углом поворота (ШИМ - широтно-импульсная модуляция, PWM).
 * Версия 4: автоматное программирование на базе таблицы переходов.
 * 
 * Конечный Автомат "TSC_Servo" производит пошаговое перемещение "туда и обратно" асинхронно
 * с КА "Блинк" (см. пример TSC_Blink.ino).
 *
 * Примечание:
 *   Положения и шаг поворота задаются в миллисекундах. Если нужно поворачивать в угловых единицах,
 *     то используйте функцию map() из стандартной библиотеки. (Не подключается в этом режиме).
 *   Для примера здесь показана возможность изменения поведения КА из своих же собственных методов
 *     управления. При достижении края, автомат переключается на обратное движение прямой сменой состояния.
 * 
 * Для работы можно использовать любую ножку PWM управления от 16-и битных таймеров. Пересчет в номер
 * таймера по номеру ножки - встроен в макрокоманды и производится препроцессором.
 *
 * @author Arhat109 arhat109@mail.ru, +7-(951)-388-2793
 * 
 * Лицензия:
 * 1. Полностью свободное и бесплатное программное обеспечение. В том числе и от претензий.
 * 2. Вы вправе использовать его на свои нужды произвольным образом и на свой риск.
 * 3. Вы не вправе удалять из него строку с тегом @author или изменять её.
 * 4. Изменяя этот файл, Вы вправе дописать свои авторские данные и/или пояснения.
 * 
 * Если Вам это оказалось полезным, то Вы можете по-достоинству оценить мой труд
 * "на свое усмотрение" (напр. кинуть денег на телефон "сколько не жалко")
 */

#include "arhat.h"
#include "tsc.h"

// ============= Blink13 ============= //

#define BLINK13_ON   150          // Включен 0.15сек
#define BLINK13_OFF  850          // Выключен 0.85сек. Период = 1сек.

// .. Таблица переходов КА (нумерация с 0!):
const TSC_Step PROGMEM        tblBlink13[2] = {
/* {command, timeout,   next} */
   { to_on, BLINK13_ON,   1 }      // "выключен": включить, перейти к состоянию "включен" с задержкой
  ,{ to_off, BLINK13_OFF, 0 }      // "включен": всё наоборот, выключаем, переходим к пред. состоянию.
};

// .. Методы, исполняемые при изменении состояния КА:
void to_on(void *_ctrl) { digitalWrite(pinLed, HIGH); }     // .. включаем светодиод
void to_off(void *_ctrl){ digitalWrite(pinLed, LOW); }      // .. выключаем светодиод

TSC_Control     blink13;     // тут будем хранить текущие данные этого КА

// ============ Servo ============ //
#define servoPin       12               // к 12 ножке подключен серводвигатель SG-90
#define DEG_0         150               // минимальное значение ширины импульса будем считать это как "0 градусов"
#define DEG_180       614               // максимальное значение для моего двигателя. Будет "180 градусов"
#define DEG_STEP        8               // шаг с которым будем поворачивать двигатель (3 грд.)
#define SERVO_WAIT      8               // =3*(120/60) + 2(запас) ТТХ сервы: за 0.12сек на 60грд!
#define STUPID        100               // время задержки состояния "все сделано", чтобы "не так шустро носился".

uint16_t        position;               // текущее положение серводвигателя
TSC_Control     servo;                  // тут будем хранить текущее состояние этого КА

// .. Методы, исполняемые при изменении состояния КА:
void servoForward(void *_ctrl)
{
  position += DEG_STEP;                 // увеличиваем угол
  if( position >= DEG_180 ){            // уперлись? меняем состояние на "назад"
    position = DEG_180;
    tsc_next(&servo, 3);
  }
  pwmWrite(servoPin, position);         // поворачиваем серводвигатель на угол
}
void servoBack(void *_ctrl)
{
  position -= DEG_STEP;                 // уменьшаем угол
  if( position <= DEG_0 ){              // если уперлись меняем направление на "вперед"
    position = DEG_0;
    tsc_next(&servo, 0);
  }
  pwmWrite(servoPin, position);         // поворачиваем на угол
}
void servoNOP(void *_ctrl) { return; }             // пропуск действия

const TSC_Step PROGMEM        tblServo[] = {
/* {  command,      timeout, next} */
   { servoForward, 0,          1 }      // 0: "вперед на шаг": запуск серводвигателя.
  ,{ servoNOP,     SERVO_WAIT, 2 }      // 1: Пустое действие, ожидание завершения поворота двигателем.
  ,{ servoNOP,     STUPID,     0 }      // 2: поворот завершен, повторяем запуск шага.
  ,{ servoBack,    0,          4 }      // 3: "назад на шаг": запуск двигателя.
  ,{ servoNOP,     SERVO_WAIT, 5 }      // 4: ожидание завершения поворота сервы.
  ,{ servoNOP,     STUPID,     3 }      // 5: поворот завершен, повторяем движение обратно
};

// *********** начальные установки: **************** //
void setup()
{
  pwmSetServo(servoPin);                // включаем режим "аппаратное серво" для таймера и ножки
  pinModeOut(servoPin);                 // и открываем её на "вывод" (изначально все ножки включаются "на ввод"!)
  pinModeOut(pinLed);                   // == pinLed == 13!!! Контрольный светодиод тоже на вывод

  position = DEG_0;                      // начинать будем с положения deg0

  tsc_init(&blink13, tblBlink13, 0);    // добавляем КА "Blink" и задаем его начальное состояние
  tsc_init(&servo,   tblServo,   0);    // добавляем КА "Servo" и задаем его начальное состояние
}

// *********** повторяем это: ************************//
void loop()
{
  tsc_step( &blink13 );                 // запускаем КА Blink13 на 1 шаг
  tsc_step( &servo);                    // запускаем КА Servo на 1 шаг
}