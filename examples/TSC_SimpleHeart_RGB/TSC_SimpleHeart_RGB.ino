/**
 * "Сердечко". Вариант 3 КА (RGB) на базе отдельной структуры данных КА.
 * размер скетча при компиляции 992 байт. SRAM = 47байт.
 *
 * Аппаратное, плавное управление яркостью каналов RGB светодиода (ШИМ - широтно-импульсная модуляция, PWM)
 * Изменяем яркость за счет изменения ширины (длительности) импульса (1) и его паузы (0) при одной и той же
 * тактовой частоте следования импульсов (тут стандартно 16МГц/64/256=976Гц.)
 *
 * "Сердечный ритм" задается последовательностью предельных значений яркости (массив starts)
 * и набором шагов (скорости) изменения яркости (ширины импульсов). На каждой стадии цикла
 * из массива starts[] выбираются 2 соседних элемента для определения "начала" и "конца" стадии.
 *
 * Дополнительно подключаем КА "контрольный светодиод", который будет моргать по секундно.
 * 
 * Примечание:
 * поскольку чиселки небольшие, то крайние значения надо выбирать так, чтобы добавляя или убавляя
 * шаг не выйти через переполнение (<256). В противном случае, получится не то что вы ожидали увидеть.
 *
 * Лицензия:
 * 1. Полностью свободное и бесплатное программное обеспечение. В том числе и от претензий.
 * 2. Вы вправе использовать его на свои нужды произвольным образом и на свой риск.
 * 3. Вы не вправе удалять из него строку с тегом @author или изменять её.
 * 4. Изменяя этот файл, Вы вправе дописать свои авторские данные и/или пояснения.
 * 
 * Если Вам это оказалось полезным, то Вы можете по-достоинству оценить мой труд
 * "на свое усмотрение" (напр. кинуть денег на телефон "сколько не жалко")
 * 
 * @author Arhat109 arhat109@mail.ru, +7-(951)-388-2793
 */

#include "arhat.h"
#include "tsc.h"

#define pinRed          pin9    // нога со светодиодом R для плавного управления яркостью
#define pinGreen        pin4    // нога со светодиодом G для плавного управления яркостью
#define pinBlue         pin10   // нога со светодиодом B для плавного управления яркостью

#define WAIT_STEP       29      // тиков, 30 миллисекунд на 1 шаг изменения яркости
#define WAIT_CYCLE      156     // .., 160 миллисекунд паузы между повторением

#define WAIT_ON         98      // .., 100 мсек интервал включение контрольного светодиода (pinLed = 13)
#define WAIT_OFF        878     // .., 900 мсек интервал выключения контрольного светодиода

#define TSC_RED         0       // все КА в одном массиве данных. Тут их номера в этом массиве
#define TSC_GREEN       1
#define TSC_BLUE        2
#define MAX_CONTROLS    3       // .. и сколько всего конечных автоматов в нем

#define WAIT_GREEN_START 5000   // пауза от включения до запуска второго КА.
#define WAIT_BLUE_START  3000   // время в тиках до запуска третьего КА.

// ======== КА blink отдельно: моргалка контрольным светодиодом ========= //
uint32_t blinkWait;             // текущий интервал ожидания. WAIT_ON или WAIT_OFF могут отличаться!
uint8_t  blinkState;            // текущее состояние светодиода. НЕЛЬЗЯ прочитать через digitalRead() !!!

// ======== КА heart: сердечко ========= //
// Общая часть описания КА "Сердечко": порядок моргания и общая функция управления КА

// пределы яркости: каждая пара соседних чисел: "от".."до"
// сначала плавно растим яркость от 10 до 240, затем гасим от 240 до 20,
// снова увеличиваем от 20 до 230 и потом уменьшаем от 230 до 10
// ... и далее "по кругу". Конец всегда должен быть равен началу.
uint8_t starts[] = {10,230,20,230,10};

// скорость изменения яркости: шагов меньше на один чем пределов!
#define MAX_STEPS   4
uint8_t steps[] = {20,15,15,10};

// Детали КА "Сердечко": счетчики стадии и текущая яркость
// тут храним текущие данные по управлению состояниями всех 3-х КА: команду, начало и длительность интервала
// можно настроить каждый КА на свое стартовое время от запуска Ардуино и начальный интервал, если надо.
// каждый КА управляется своей командой. Если команды нет - то запуска не будет (можно отключать КА нулем).
// тут: TSC_RED - запуск сразу "как только", TSC_GREEN - запуск через 5сек от включения, TSC_BLUE - сам не запускается.
// все начинают с нулевого шага и нулевой яркостью.
struct Hearts_Data {
  TSC_Simple    ctrl;           // управляющие данные этим КА (started_at, timeout, command)
  uint8_t       state;          // номер стадии в steps[] данного КА
  uint8_t       light;          // текущяя яркость свечения 0..255
} hearts[MAX_CONTROLS] = 
{
/* {{ start,timeout,    command  },state,light } */
/* --------------------------------------------- */
   {{  0, WAIT_STEP,  doHeartRed }, 0,    0}  // red: красный светодиод
  ,{{  0, 5000     , doHeartGreen}, 0,    0}  // green: зеленый - запуск на 50й секунде от включения
  ,{{  0, WAIT_STEP,       0     }, 0,    0}  // blue: синий - нет команды, запуск из зеленого КА
};

// Пример единой функции действий для 3-х КА в виде явной "функции переходов" между их состояниями
void doHeart(uint8_t _num)
{
  struct Hearts_Data * cur = &(hearts[_num]);
  uint8_t curMax  = starts[cur->state];
  uint8_t nextMax = starts[cur->state + 1];

  if( nextMax > curMax ){                               // яркость - увеличиваем?
    cur->light += steps[cur->state];
    if( cur->light >= nextMax ){                        // . дошли до максиума яркости стадии?
      ++(cur->state);                                   // .. переходим на след. стадию.
    }
  } else {
    cur->light -= steps[cur->state];
    if( cur->light <= nextMax ){                        // . уменьшаем текущую яркость. Миниум?
      ++cur->state;                                     // .. переходим на след. стадию.
    }
  }
  if( cur->state >= MAX_STEPS ){
    cur->state = 0;                                     // стадии кончились? Всё с начала.
  };
}

// ******** Функции отдельных КА: ******** //

// RED: просто моргаем в стиле сердечко. Пример работы с параметром - указателем на структуру данных этого КА
void doHeartRed(void *ctrl)
{
  doHeart(TSC_RED);                                     // общие действия по определению состояния красного КА
  analogWrite(pinRed, ((Hearts_Data *)ctrl)->light);    // нога управления - константа!!!
}

// GREEN: если не включен, то включаем синий канал, через 3сек. Работа с данными напрямую (номер известен)
void doHeartGreen(void *ctrl)
{
  doHeart(TSC_GREEN);
  hearts[TSC_GREEN].ctrl.timeout = WAIT_STEP;           // принудительно меняем ожидание на типовое с начальных 5сек!
  if( ! hearts[TSC_BLUE].ctrl.command )                 // синий - выключен?
  {
    hearts[TSC_BLUE].ctrl.command = doHeartBlue;        // исполнять будем это: включаем синий КА
    hearts[TSC_BLUE].ctrl.timeout = WAIT_BLUE_START;    // через столько тиков
    hearts[TSC_BLUE].ctrl.started_at = tsc_getTime();   // от этого момента времени
  }
  analogWrite(pinGreen, hearts[TSC_GREEN].light);       // устанавливаем яркость своего LED
}

// BLUE: выключает красный канал в начале своей третьей стадии.
void doHeartBlue(void *_ctrl)
{
  doHeart(TSC_BLUE);
  ((Hearts_Data *)_ctrl)->ctrl.timeout = WAIT_STEP;     // и тут тоже меняем интервал КА на стандартный

  if( ((Hearts_Data *)_ctrl)->state == 3 && hearts[TSC_RED].ctrl.command )
  {
    analogWrite(pinRed, 0);                             // выключаем яркость
    hearts[TSC_RED].ctrl.command = 0;                   // и останавливаем красный КА
  }
  analogWrite(pinBlue, ((Hearts_Data *)_ctrl)->light);
}

// ======== Остаток типового скетча: настройки в setup() и повтор действий КА в loop()
void setup() {
  pinMode(pinLed, OUTPUT);      // контрольная 13 нога (встроенный светодиод)

  pwmSet(pinRed);               // включаем 4-ю ногу в режим ШИМ (PWM) и на выход
  pwmSet(pinBlue);              // включаем 10-ю ногу в режим ШИМ (PWM) и на выход
  pwmSet(pinGreen);             // включаем 9-ю ногу в режим ШИМ (PWM) и на выход

  // начальные установки КА: всё в нули, поставят сами при первом вызове
  blinkWait = blinkState = 0;
}

void loop() {
  // пример КА, реализуемый непосредственно внутри вызова макроса:
  everyOVF(blinkWait,
  {
    if( blinkState == 0 ) { blinkState = 1; blinkWait = WAIT_ON; }
    else                  { blinkState = 0; blinkWait = WAIT_OFF; }
    digitalWrite(pinLed, blinkState);
  });

  // Запускаем все КА циклом:
  for( int i=0; i<MAX_CONTROLS; i++)
    tsc_run( &(hearts[i].ctrl) );
}