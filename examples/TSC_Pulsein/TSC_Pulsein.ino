/**
 * Пример измерения длительности импульсов с помощью конечных автоматов на прерываниях от PCINT2.
 * Здесь же пример реализации "библиотеки" для ультразвукового датчика HCSR-04 в автоматном стиле.
 * 
 * Библиотека реализована как h-файл, подключающийся в скетч. Для корректной работы, предварительно требуется
 * определить константы, использующиеся в библиотеке:
 * пин для ноги trig, пин для ноги echo датчика и номер КА. До первого подключения надо указать общее количество
 * устройств, которые будут использовать замер длительностей по прерываниям.
 * В результате создается (template) функция запуска измерений датчиком в виде
 * 
 * void startTrigNN(void *), где NN - номер пина сигнала trig, принимающая указатель на свой КА
 * 
 * Результат измерения действителен, когда в поле state значение PULSE_OK. Значение в микросекундах!
 * Пересчитывать в метры, сантиметры и т.д. - самостоятельно. Тут пересчет в миллиметры.
 * 
 * Таймаут измерения расстояний библиотека устанавливает в 35 миллисекунд, что соответствует примерно 6 метрам.
 * В примере, обработка результата замера вынесена в основной скетч намерено.
 * Ничто не мешает использовать проверку состояния в любом другом месте или выделить в отдельную функцию.
 * Раскрыв комментарий в switch() можно смотреть изменения служебных состояний датчиков
 *
 * Pulse.h (интегрирован в tsc.h):
 * -------------------------------
 * Замер длительностей реализован в том же файле-заголовке, что и все автоматные определения. Включается в
 * компиляцию только при предопределенной константе MAX_PULSES - количество задействованных ножек прерываний
 * уровня PCINT2 (пины Ардуино с 62 по 69 они же аналоговые входы с 8 по 15).
 * 
 * Замер длительности, в общем виде запускается функцией pulse_start() @see tsc.h,
 * которая настраивает и разрешает прерывания уровня PCINT2 для соответствующей ноги, а также
 * включает КА для отслеживания таймаута измерения длительности. Как только замер завершен,
 * об этом можно узнать из поля state данных КА.
 * 
 * Номера пинов для измерения длительности импульсов - указывать в общей нумерации: с 62 по 69.
 * 
 * Как пример, библиотека "hcsr04.h" подключается дважды, для обслуживания двух датчиков одновременно.
 * Перед последующими подключениями надо переопределять номера пинов для нового датчика.
 * 
 * Лицензия:
 * 1. Полностью свободное и бесплатное программное обеспечение. В том числе и от претензий.
 * 2. Вы вправе использовать его на свои нужды произвольным образом и на свой риск.
 * 3. Вы не вправе удалять из него строку с тегом @author или изменять её.
 * 4. Изменяя этот файл, Вы вправе дописать свои авторские данные и/или пояснения.
 * 
 * Если Вам это оказалось полезным, то Вы можете по-достоинству оценить мой труд
 * "на свое усмотрение" (напр. кинуть денег на телефон "сколько не жалко")
 * 
 * @author Arhat109 arhat109@mail.ru, +7-(951)-388-2793
 */
#include "arhat.h"

#define MAX_PULSES  2           // Это надо определить ДО использования прерывания PCINT2

#define trigPin 22              // Первый датчик, сигнал trig подключен к этому пину Ардуино.
#define echoPin 69              // .. его сигнал echo подключается сюда (Аналог 8)
#define PULSE_ID 0              // .. его номер с массиве КА для измерения длительностей импульсов
#include "hcsr04.h"             // первое подключение библиотеки. tsc.h вызывается отсюда самостоятельно.

#define trigPin 24              // Второй датчик, его нога trig подключена сюда
#define echoPin 63              // .. его нога echo подключается сюда
#define PULSE_ID 1              // .. номер структуры данных результатов измерения второго датчика
#include "hcsr04.h"             // повторный вызов библиотеки для создания КА для второго датчика

void setup() {
  // пины для сигналов echo -- предварительно устанавливать не требуется: по умолчанию это входы.
  pinModeOut(22);                       // нога trig первого датчика "на выход"
  pinModeOut(24);                       // аналогично для второго.. ноги echo устанавливаются при запуске измерений

  pulses[0].state = HCSR04_START;       // исключительно для примера, можно и PULSE_OK 
  pulses[1].state = HCSR04_START;

  Serial.begin( 9600 );
}

void loop()
{
  for(int i=0; i<MAX_PULSES; i++)
  {
    // исполняем шаг КА: таймаут, запуск, или ничего не делает.
    tsc_run((TSC_Simple *)&pulses[i].ctrl);

    switch( pulses[i].state ) {
    case HCSR04_START:                                  // запуск замера через 0.5сек:
      tsc_simple( &(pulses[i].ctrl)                     // изменяем КА вручную:
        , (i==0? startTrig22 : startTrig24)             // .. исполнить команду запуска измерения соответствующего датчика
        , 976                                           // .. через 1 сек. = 976 тиков таймера
      );
      pulses[i].state = 0;                              // .. сброс состояния, чтобы ничего в switch не делать... нечего. Просто ждем.
      Serial.print( i );                                // вывод какой датчик запускаем.
      Serial.println( " started" );
      break;
    case PULSE_OK:                                      // замер произведен, данные - действительны:
      Serial.print( i );                                // вывод какой датчик сработал.
      Serial.print( "=" );
      Serial.println( getDistance(&pulses[i]), DEC );   // вывод полученного расстояния для датчика.
      pulses[i].state = HCSR04_START;                   // меняем статус датчика на подготовку к замеру
      break;
    case PULSE_ERROR:                                   // ошибка измерения (обнаружен только один фронт)
    case PULSE_TIMER:                                   // или сработал КА по таймауту.
      Serial.print( i );
      Serial.println(" : error");
      pulses[i].state = HCSR04_START;                   // и сбрасываем состояние датчика на запуск с ожиданием просмотра.
      break;
// пример анализа прочих состояний КА датчика - они служебные не использовать без надобности!
//    case PULSE_BUSY:
//      Serial.print(i);                                  // ждем прерывание по началу импульса
//      Serial.print(" - busy ");
//      Serial.println(pcint2old, DEC);                   // и показываем состояние всех ножек прерывания десятичным числом
//      break;
//    case PULSE_SECOND:                                  // ждем прерывание по концу импульса
//      Serial.print(i);
//      Serial.print(" - second: ");
//      Serial.println(pcint2old, DEC);
//      break;
    }
  }
}