/**
 * Пример измерения длительности импульсов с помощью конечных автоматов на прерываниях от PCINT2.
 * Здесь же пример реализации "библиотеки" для ультразвукового датчика HCSR-04 в автоматном стиле.
 *
 * Библиотека реализована как h-файл, подключающийся в скетч. Для корректной работы, предварительно требуется
 * определить константы, использующиеся в библиотеке:
 * пин для ноги trig, пин для ноги echo датчика и номер КА. До первого подключения надо указать общее количество
 * устройств, которые будут использовать замер длительностей по прерываниям и уровень прерываний (можно не только PCINT2).
 * В результате создаются (template) функции запуска измерений датчиком и управления прерываниями в виде
 *
 * void     startTrigNN  (void *);, где NN - номер пина сигнала trig, принимающая указатель на свой КА
 *
 * TSC_Time pulseIn0     (uint8_t pulseId, void (*action)(void));
 * uint8_t  pcint0_init  (uint8_t pulseID, uint8_t pin, uint8_t state, PcintMethod method, TSC_Time timeout);
 * void     pcint0_start (uint8_t intNumber);
 * , где 0 может быть заменен на указанный номер прерывания в константе PCINT перед подключением #include "pcint.h"
 * 
 * Результат измерения действителен, когда в поле state значение PULSE_OK. Значение в микросекундах!
 * Пересчитывать в метры, сантиметры и т.д. - самостоятельно. Тут пересчет в миллиметры.
 *
 * Таймаут измерения расстояний библиотека устанавливает в 35 миллисекунд, что соответствует примерно 6 метрам.
 * В примере, обработка результата замера вынесена в основной скетч намерено.
 * Ничто не мешает использовать проверку состояния в любом другом месте или выделить в отдельную функцию.
 * Раскрыв комментарий в switch() можно смотреть изменения служебных состояний датчиков
 *
 * pcint.h: автоподключается из "hcsr04.h"
 * ---------------------------------------
 * Включается в компиляцию только при предопределенных константах PCINT и MAX_PULSES{0..2} - количество задействованных
 * ножек прерываний соответствующего уровня.
 *
 * Замер длительности, в общем виде начинается с функции pcintX_init() @see pcint.h, которая настраивает структуру данных
 * для работы с прерываниями: устанавливает соответствие номера в массиве структур уровня пина и номера прерывания,
 * устанавливает метод измерения и настраивает таймаут. Основное назначение - setup().
 * Тут как пример, реализовано для второго датчика.
 * Запуск начала измерения осуществляется функцией pcintX_start() @see pcint.h, которая принимает локальный номер ноги 
 * прерывания, настраивает регистры и разрешает прерывания PCINT .. для соответствующей ноги.
 * Как только замер завершен, об этом можно узнать из поля state данных КА.
 *
 * Метод обработки прерывания указывается косвенно в структуре данных pulsesX[N] и есть реализация двух методов:
 *   void pcint_micros( void *ptr, uint8_t oldBit );  -- замер длительности импульса с таймаутом
 *   void pcint_encoder( void *ptr, uint8_t oldBit ); -- подсчет импульсов по фронту/спаду и т.д. с таймаутом или непрерывно.
 * можно придумать ещё..
 *
 * Номера пинов для измерения длительности импульсов - указывать в общей нумерации:
 * для Мега2560: 10..12 (13 никак! Это "выход") и 50..53 -- для PCINT0 и 62 по 69 для PCINT2.
 * Прерывания PCINT1 для Mega2560 -- НЕ реализованы.
 *
 * Как пример, библиотека "hcsr04.h" подключается дважды, для обслуживания двух датчиков одновременно.
 * Перед последующими подключениями надо переопределять номера пинов для нового датчика и если надо то
 * и описания нового уровня PCINT. Тут намерено второй датчик обслуживается другим уровнем. Если несколько
 * датчиков сидят на одном уровне прерываний то определять повторно константы PCINT.., MAX_PULSES.. - не зачем.
 *
 * Тем не менее тут, второй датчик обслуживается прямыми функциями настройки и запуска прерывания исключительно как пример.
 *
 * Требуемые объемы:
 *   Каждый новый уровень прерываний отжирает 296 байт кода и 9 байт данных под свою работу
 *   Каждое новое прерывание одного уровня отжирает 14 байт данных под хранение структуры в pulsesX
 *   Каждый новый датчик HCSR-04 (новое включение hcsr04.h) отжирает 106 байт кода на функцию управления им startTrigNN()
 *
 *   Каждое прерывание отрабатывает примерно 15тактов на начало + 8тактов на поиск сработавшей ноги в цикле + 7тактов на запуск
 * метода обработки и возврата из него + время на отработку метода измерений.
 * Итого получаем оценку времени около: 15 + N*(15+t) + M*8, где N+M<=8, N - количество сработавших ног, M - количество просмотренных
 * ног без срабатывания. Так, если сработала 69 нога (PCINT2:7), то N=1,M=7. А если сработала только 62 нога, то N=1,M=0 :)
 *
 * рекомендации:
 * 1. С целью уменьшения кода желательно использовать один уровень прерываний;
 * 2. Прерывания одного уровня при каждом срабатывании просматриваются от 0 к 7, но не все, а только сработавшие. Соответственно
 *    те обработчики, которые чаще срабатывают в вашем коде желательно располагать на меньших номерах прерываний.
 *
 * Лицензия:
 * 1. Полностью свободное и бесплатное программное обеспечение. В том числе и от претензий.
 * 2. Вы вправе использовать его на свои нужды произвольным образом и на свой риск.
 * 3. Вы не вправе удалять из него строку с тегом @author или изменять её.
 * 4. Изменяя этот файл, Вы вправе дописать свои авторские данные и/или пояснения.
 *
 * Если Вам это оказалось полезным, то Вы можете по-достоинству оценить мой труд
 * "на свое усмотрение" (напр. кинуть денег на телефон "сколько не жалко")
 *
 * @author Arhat109 arhat109@mail.ru, +7-(951)-388-2793
 */
#include "arhat.h"

#define PCINT        2          // компиляем под PCINT уровень 2
#define MAX_PULSES2  1          // .. в нем задействована 1 нога прерываний

#define trigPin     14          // Первый датчик, сигнал trig подключен к этому пину Ардуино.
#define echoPin     69          // .. его сигнал echo подключается сюда (Analog15==PCINT2:7)
#define PULSE_ID     0          // .. его номер с массиве КА для измерения длительностей импульсов
#include "hcsr04.h"             // первое подключение библиотеки. tsc.h вызывается отсюда самостоятельно.

#define PCINT        0          // а тут будем использовать прерывание PCINT0
#define MAX_PULSES0  1          // .. в нем тоже только один датчик

#define trigPin     15          // Второй датчик, его нога trig подключена сюда
#define echoPin     10          // .. его нога echo подключается сюда (pwm10==PCINT0:4)
#define PULSE_ID     0          // .. номер структуры данных результатов измерения второго датчика
#include "hcsr04.h"             // повторный вызов библиотеки для создания КА для второго датчика

// Далее использованы чиселки, поскольку trigPin, echoPin, PULE_ID относятся только ко второму датчику!
// если хотите использовать #define, то их надо определить со своими, скетчевыми именами, а не для template..

void setup() {
  // пины для сигналов echo -- предварительно устанавливать не требуется: по умолчанию это входы.
  pinModeOut(14);                       // нога trig первого датчика "на выход"
  pinModeOut(15);                       // аналогично для второго.. ноги echo устанавливаются при запуске измерений

  pulses2[0].state = HCSR04_START;      // исключительно для примера, можно и PULSE_OK
  
  // перенастраиваем второй датчик ручками, примера для:
  // pulses0[0].state = HCSR04_START;
  pcint0_init(0, 10, PULSE_BUSY, pcint_micros, 29);  // номер=0, пин=10, начало замера, замер длительности, не дольше 30мсек

  Serial.begin( 9600 );
}

void loop()
{
  for(int i=0; i<2; i++)
  {
    Pulse *ptr;
    
    if( i==0 ) { ptr = &pulses2[0]; }
    else       { ptr = &pulses0[0]; }

    // исполняем шаг КА: таймаут, запуск, или ничего не делает.
    tsc_run( &ptr->ctrl );

    switch( ptr->state ) {
    case HCSR04_START:                                  // запуск замера:
      tsc_simple( &(ptr->ctrl)                          // изменяем КА вручную:
        , (i==0? startTrig14 : startTrig15)             // .. исполнить команду запуска измерения соответствующего датчика
        , 976                                           // .. через 1 сек. = 976 тиков таймера
      );
      ptr->state = 0;                                   // .. сброс состояния, чтобы ничего в switch не делать... нечего. Просто ждем.
      Serial.print( i );                                // вывод какой датчик запускаем.
      Serial.println( " started" );
      break;
    case PULSE_OK:                                      // замер произведен, данные - действительны:
      Serial.print( i );                                // вывод какой датчик сработал.
      Serial.print( "=" );
      Serial.println( getDistance(ptr), DEC );          // вывод полученного расстояния для датчика.
      ptr->state = HCSR04_START;                        // меняем статус датчика на подготовку к замеру
      break;
    case PULSE_ERROR:                                   // ошибка измерения (обнаружен только один фронт)
    case PULSE_TIMER:                                   // или сработал КА по таймауту.
      Serial.print( i );
      Serial.println(" : error");
      ptr->state = HCSR04_START;                        // и сбрасываем состояние датчика на запуск с ожиданием просмотра.
      break;
// пример анализа прочих состояний КА датчика - они служебные не использовать без надобности!
//    case PULSE_BUSY:
//      Serial.print(i);                                  // ждем прерывание по началу импульса
//      Serial.print(" - busy ");
//      Serial.println(pcint2old, DEC);                   // и показываем состояние всех ножек прерывания десятичным числом
//      break;
//    case PULSE_SECOND:                                  // ждем прерывание по концу импульса
//      Serial.print(i);
//      Serial.print(" - second: ");
//      Serial.println(pcint2old, DEC);
//      break;
    }
  }}
